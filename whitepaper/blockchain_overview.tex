\section{AppCoins: Protocol Construction}

Our solution solves the use cases of Advertising, In-App Billing (IAB) and Developer Reputation within App Stores by leveraging the blockchain construction to create value for the different participants.\\

As it works today, advertising in App Stores is a flow composed by a campaign created by the developer, which is submitted to the several networks of campaigns. App Stores then connect to these networks and get the active campaigns, trying to have their users converting them. As it is now, the value is diluted through all the networks and the most relevant players, which are the developers and the App Stores, are the ones losing the most value, since the latter receive a small amount per conversion compared to the networks, and the former have to pay more than necessary in order to make it interesting for the App Stores to get their campaigns.

The developers and the App Stores should be the players getting the most for their effort, since they are the creators of most of the value in the flow by either creating the apps or by distributing and making them available for the users.\\

In IAB, developers provide content inside their apps, which can be exchanged for money. They integrate third-party SDKs that handle the payments and those third-parties (e.g. Google Play) receive a large amount of the payments, which is between 15\% to 30\% for the larger players in the market (Google Play \footnote{https://support.google.com/googleplay/android-developer/answer/1153481}, Apple \footnote{https://developer.apple.com/app-store/subscriptions/}).

Once again, the players creating the most value, i.e. the developers, should be the ones actively rewarded for their effort and the players supporting them should, i.e. App Stores, not ask for so much in return.\\

Moreover, in both the above scenarios, the OEMs that preload the App Stores in their devices are not included in the value chain of all these transactions. Our solution comprises incentives for OEMs to preload App Stores that add the most value to users as well as to them.\\

The Developer Reputation problem is the one from the mentioned three that, when not addressed properly, can harm users the most. Malignant apps can harm users in several ways, ranging from the most extreme as theft of personal information and device inoperability, to the less harmful as apps containing (almost) only ads or non-working apps. For App Stores with already considerable reach, i.e. already with several millions of users, malignant apps can find their way to a significant amount of devices and thus need to be taken care of before reaching the users.

Today this assessment of apps and developers is done in a centralised way, i.e. each App Store uses its own system, and there is no shared knowledge between App Stores. Our solution includes an approach for the categorisation of developers based on the usage of their apps by the users, and the ability to share knowledge between App Stores.\\

In this section, we present the data structures and algorithms used to solve each of the aforementioned use cases. It will be organised as follows: a section for each use case and subsections explaining the data structures and the algorithms.

\subsection{Advertising}

Advertising campaigns in the context of a blockchain construction must be constructed in a way to overcome the following problems:
\begin{itemize}
\item \textit{Double attribution problem}: For all instances of the same bid (explained in \ref{sssec:ads_ds}) in different App Stores, a user can only be attributed once.
\item \textit{Bid refutation}: A developer must not be able to state that he did not create a bid if it is not true.
\item \textit{Bid validation}: A developer must be able to confirm that the attribution rules match the ones submitted at campaign (explained in \ref{sssec:ads_ds}) creation time.
\end{itemize}

\subsubsection{Data Structures} \label{sssec:ads_ds}

\noindent \textbf{Campaign}. A \textit{campaign} is a statement of intent to pay the attention of users. Developers create \textit{campaigns} and submit them to App Stores, which in turn match and propagate them to users. Campaigns are composed by an amount of funds, a duration, the amount of tokens per attribution, and the filters (app name, app version, geolocation,...). Please refer to Table \ref{table: data_structures_ad} for more details. \\

\noindent \textbf{Bid}. A \textit{bid} is a mapping between developers and the users in an App Store that match specific campaigns created by developers. It also contains the funds available for the \textit{bid} and the amount of tokens per attribution, and its duration.\\

\noindent \textbf{Inverted bid}. An \textit{inverted bid} is a mapping between users and the bids they are participating in for a specific app store. See Table \ref{table: data_structures_ad} for more details.\\

\noindent \textbf{Ledger}. The \textit{ledger} is the record of attributions, i.e. users that did the required action (having an app open for at least 2 minutes) for a bid. The ledger is populated in a way that avoids the \textit{double attribution problem}, i.e. bids in different App Stores for the same apps in similar time intervals need to be identifiable across all the stores, as well as the users.

\begin{table}[H]
\footnotesize
\centering
\begin{tabular}{|p{.5\textwidth}p{.5\textwidth}|}
\hline
\multicolumn{2}{|c|}{Data Structures} \\
\hline \vspace{0.05cm}
\textbf{Campaign} & \vspace{0.05cm} \textbf{Bid} \\
campaign $C_{ij} := \langle F_{ij}, \Delta t_{ij}, T_{ij}, filters \rangle_{D_{i}, AP_{j}}$
\begin{itemize}
	\item Funds $F_{ij}$, the amount of tokens the developer $D_{i}$ is willing to spend for $C_{ij}$ in an app store $AP_{j}$
	\item Duration $\Delta t_{ij}$, the duration of $C_{ij}$ in $AP_{j}$
	\item Tokens per attribution $T_{ij}$, the amount of tokens to be sent from $D_{i}$ and distributed to the other parties per attribution
	\item Filters, the specifics of $C_{ij}$, as the app name, app version, geolocation of $C_{ij}$, and others available to $D_{i}$
\end{itemize}
& bid $B_i : \{D_1 \to (U_1..U_n)\}_{AP_j}$
\begin{itemize}
	\item Developer $D_i$, developer that submitted a bid $B_i$ to the app store $AP_j$ 
	\item User $U_i$, user matching the filters of campaign $C_{ij}$ associated with bid $B_i$ in app store $AP_j$
\end{itemize} \\
\textbf{Inverted Bid} & \textbf{Ledger} \\
inverted bid $IB_i : \{U_1 \to (B_1..B_n), U_2..\}_{AP_j}$
\begin{itemize}
	\item User $U_i$, user matching one or more bids $B_{i..n}$ in app store $AP_j$
	\item Bid $B_i$, bids submitted to app store $AP_j$
\end{itemize}
& ledger $L : (A^{1}_{t}..A^{n}_{t})$
\begin{itemize}
	\item Attribution $A^{i}_{t}$, $i$-th attribution in the ledger $L$, which is composed as a mapping $A^{i}_{t} : \{B_{N}^{j} \to (U_{N}^{1}..U{N}^{n})\}$, where $B_{N}^{j}$ is the standardised bid $B_j$ across all the app stores where it is defined and $U_{N}^{i}$ is the normalised user $U_i$ across all the app stores
\end{itemize} \\
\hline
\end{tabular}
\caption{Data Structures for Advertising Use Case}
\label{table: data_structures_ad}
\end{table}

\subsubsection{Algorithm construction}

Table \ref{table: ads_use_case} presents in pseudo-code a more in-depth definition of the following methods. \\

\noindent \textbf{Create bid}. When a campaign is submitted to the App Store, the \textsf{CreateBid} method creates the associated bid $B$ containing the mapping $M$ between the developer $D$ and the set of users $U$ of the app store that match the filters. The inverted bids $IB_{i...n}$ of the app store containing the mapping between users and the bids they are in are created or updated, if they already exist. In addition, the funds $F$ the developer wishes to allocate to the campaign are sent from the developer's wallet $W_D$ to the bid's contract wallet $W_B$. Since the created bid is in the blockchain accessible to every user, it is used to overcome the \textit{bid refutation} problem.\\

\textsf{AD.CreateBid}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item Campaign parameters:
		\begin{itemize}
			\item Funds $F$
			\item Duration $\Delta t$
			\item Tokens paid per attribution $T$
			\item Filters (geolocation, app name, app version,...)
		\end{itemize}
		\item Developer $D$
		\item App Store $AS$
	\end{itemize}
	\item OUTPUTS: Bid $B$ and inverted bid $IB$
\end{itemize}

\noindent \textbf{Validate bid}. When a bid is to be shown to the user $u$, \textsf{ValidateBid} validates that bid in the blockchain to confirm if it is a valid bid and if the user $u$ matches its filters. In order to avoid the scenario where there are not enough funds available in the bid for the user, the tokens per attribution $T$ defined in the bid are sent to the bid's captivation wallet $W_C$ for a period of time. The method is used to overcome the problem of \textit{bid validation}. \\

\textsf{AD.ValidateBid}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item User $u$
		\item App Store $AS$
	\end{itemize}
	\item OUTPUTS: Result $R$ (0 or 1)
\end{itemize}

\noindent \textsf{Set attribution}. When a user has been attributed to a bid $B$, i.e. the user performed the required action (e.g. had the app open for at least 2 minutes), \textsf{SetAttribution} checks the ledger $L$ to make sure the user $u$ has not yet been attributed to the bid $B$ and if so, the attribution is written in the ledger and each participant receives the correspondent tokens, i.e. the user, OEM and app store receive $T_u$, $T_{OEM}$ and $T_{AS}$, respectively. Since the method is constructed in a way such that the same user is unable to be attributed the same bid in different app stores, it avoids the \textit{double attribution problem}. \\

\textbf{AD.SetAttribution}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item User $u$
		\item Bid $B$
	\end{itemize}
	\item OUTPUTS: Result $R$ (0 or 1)
\end{itemize}

\begin{table}[H]
\scriptsize
\centering
\begin{tabular}{|p{.5\textwidth}p{.5\textwidth}|}
\hline
\multicolumn{2}{|c|}{Advertising Use Case} \\
\hline \vspace{0.1cm}
\textsf{AD.CreateBid}
\begin{itemize}
	\vspace{-0.3cm}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item Campaign parameters:
		\begin{itemize}
			\item Funds $F$
			\item Duration $\Delta t$
			\item Tokens paid per attribution $T$
			\item Filters (geolocation, app name,...)
		\end{itemize}
		\item Developer $D$
		\item App Store $AS$
	\end{itemize}
	\item OUTPUTS: Bid $B$ and inverted bid $IB$
\end{itemize}
\begin{enumerate}
	\item Compute $U$ := \textsf{GetUsers}($AS$, $filters$)
	\item Compute $M$ := \textsf{Mapping}($D$, $U$)
	\item Compute $B$ := \textsf{CreateBid}($F$, $D$, $\Delta t$, $T$, $filters$, $M$)
	\item Send $F$ from developer's wallet $W_D$ to bid's wallet $W_B$
	\item For each $u$ in $U$:
	\vspace{-0.3cm}
	\begin{enumerate}
		\item Compute $IB_u$ := \textsf{GetIB}($u$)
		\item If $IB_u = -1$: 
		\begin{enumerate}
			\item Compute $IB_u$ := \textsf{CreateIB}($u$)
		\end{enumerate}
		\item Else:
		\begin{enumerate}
		 \item Compute $IB_u$.\textsf{append}($B$)
		\end{enumerate}
	\end{enumerate}
\end{enumerate} & \vspace{0.1cm} \textsf{AD.SetAttribution}
\begin{itemize}
	\vspace{-0.3cm}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item User $u$
		\item Bid $B$
	\end{itemize}
	\item OUTPUTS: Result $R$
\end{itemize}
\begin{enumerate}
	\item Compute $InLedger$ := \textsf{CheckLedger}($u$, $B$)
	\item If $InLedger$ = 1:
	\begin{itemize}
		\item Set $R$ := 0
	\end{itemize}
	\item If $InLedger$ = 0:
	\begin{enumerate}
		\item Compute $TX$ := \textsf{Transaction}($u$, $B$)
		\item Compute $R$ := \textsf{WriteLedger}($TX$)
		\item Compute $(T_u, T_{OEM}, T_{AS})$ := \textsf{DivideTokens}($T$)
		\item Send $T_u$ to user's wallet $W_U$
		\item Send $T_{OEM}$ to OEM's wallet $W_{OEM}$
		\item Send $T_{AS}$ to user's wallet $W_{AS}$
	\end{enumerate}
\end{enumerate} \\
\textsf{AD.ValidateBid}
\begin{itemize}
	\vspace{-0.3cm}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item User $u$
		\item App Store $AS$
	\end{itemize}
	\item OUTPUTS: Result $R$
\end{itemize}
\begin{enumerate}
	\item Compute $B^{'}_{u}$ := \textsf{GetBids}($u$, $AS$)
	\item Compute $IB_u$ = \textsf{GetIB}($u$)
	\item Set $IB^{'}_{u}$ := $\{u \to (B^{'1}_{u}..B^{'n}_{u}) = B^{'}_{u}\}$
	\item Compute $R$ := \textsf{CheckMatch}($IB_u$, $IB^{'}_{u}$)
	\item If $R = 1$:
	\begin{enumerate}
		\item Send $T$ from bid's wallet $W_B$ to bid captivation wallet $W_C$
	\end{enumerate}
\end{enumerate} & \\
\hline
\end{tabular}
\caption{Advertising Use Case}
\label{table: ads_use_case}
\end{table}

\subsection{In-App Billing}

\subsubsection{Data Structures}

\noindent \textbf{Catalog}. A \textit{catalog} is a mapping between items available in an app and their prices. Each item has only one price and the mapping is bonded to an App Store, i.e. the price can be set differently for different App Stores. \\

\noindent \textbf{Ledger}. The \textit{ledger} is the record of items bought by users. It records transactions in a way that anyone can verify an anonymous user bought a quantity $Q$ of an item $I$ for a price $P$ from an app that integrated the IAB solution from App Store $AS$.

\begin{table}[H]
\footnotesize
\centering
\begin{tabular}{|p{1.0\textwidth}|}
\hline
\multicolumn{1}{|c|}{Data Structures} \\
\hline \vspace{0.05cm}
\textbf{Catalog} \\
catalog $C_{ij} : \{I_1 \to P_1..I_n \to P_n\}_{A_i, AS_j}$
\begin{itemize}
	\item Item $I_i$, an item available in app $A_i$ which integrated IAB solution from app store $AS_j$
	\item Price $P_i$, the price of item $I_i$
\end{itemize} \\
\textbf{Ledger} \\
ledger $L : (TX_1..TX_n)$
\begin{itemize}
	\item Transaction $TX_i$, a transaction stating that an anonymous user $u$ bought a quantity $Q$ an item $I$ with price $P$ from an app $A$ that integrated the IAB solution from app store $AS$
\end{itemize} \\
\hline
\end{tabular}
\caption{Data Structures for IAB Use Case}
\label{table: data_structures_iab}
\end{table}

\subsubsection{Algorithm construction}

\noindent \textbf{Create catalog}. When a developer $D$ wants to integrate in-app purchases, a catalog $C$ is created containing the mapping between the items $I_N$ that are to be available in the app $A$ and their respective prices $P_N$. \\

\textsf{IAB.CreateCatalog}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item Set of items $I_N = (I_1..I_n)$
		\item Set of prices $P_N = (P_1..P_n)$
		\item App $A$
		\item App store $AS$
	\end{itemize}
	\item OUTPUTS: Catalog $C$
\end{itemize}

\noindent \textsf{Create transaction}. When a user $u$ wants to buy a certain amount $Q$ of items $I$, a transaction is created stating that the user $u$ bought a quantity $Q$ of an item $I$ for a price $P$ in a app $A$ that integrated the IAB solution from app store $AS$. \\

\textsf{IAB.CreateTransaction}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item User $u$
		\item Item $I$
		\item Quantity $Q$
		\item App $A$
		\item App store $AS$
	\end{itemize}
	\item OUTPUTS: Result $R$ (0 or 1)
\end{itemize}

\begin{table}[H]
\scriptsize
\centering
\begin{tabular}{|p{0.45\textwidth}p{0.55\textwidth}|}
\hline
\multicolumn{2}{|c|}{IAB Use Case} \\
\hline \vspace{0.1cm}
\textsf{IAB.CreateCatalog}
\vspace{-0.3cm}
\begin{itemize}
	\item INPUTS:
	\vspace{-0.4cm}
		\begin{itemize}
		\item Set of items $I_N = (I_1..I_n)$
		\item Set of prices $P_N = (P_1..P_n)$
		\item App $A$
		\item App store $AS$
	\end{itemize}
	\item OUTPUTS: Catalog $C$
\end{itemize}
\begin{enumerate}
	\item Compute $M$ := \textsf{Mapping}($I_N$, $P_N$)
	\item Compute $C$ := \textsf{Catalog}($M$, $A$, $AS$)
\end{enumerate} & 
\vspace{0.1cm} \textsf{IAB.CreateTransaction}
\vspace{-0.3cm}
\begin{itemize}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item User $u$
		\item Item $I$
		\item Quantity $Q$
		\item App $A$
		\item App store $AS$
	\end{itemize}
	\item OUTPUTS: Result $R$ (0 or 1)
\end{itemize}
\begin{enumerate}
	\item Compute $TX$ := \textsf{Transaction}($u$,$I$,$P$,$Q$,$A$, $AS$)
	\item Compute $R$ := \textsf{WriteLedger}($TX$)
	\item if $R = 1$:
	\begin{enumerate}
		\item App $A$ issues items to user
		\item Compute $(T_D, T_{OEM}, T_{AS})$ := \textsf{DivideTokens}($F$)
		\item Send $T_D$ to developer's wallet $W_D$
		\item Send $T_{OEM}$ to OEM's wallet $W_{OEM}$
		\item Send $T_{AS}$ to user's wallet $W_{AS}$
	\end{enumerate}
\end{enumerate} \\
\hline
\end{tabular}
\caption{IAB Use Case. In \textsf{CreateTransaction}, the issuing of items in certain app $A$ is purely done in the app based on the result of the method, since the items are not in the blockchain and there is no real blockchain transaction happening.}
\label{table: iab_protocol}
\end{table}

\subsection{Developers Approval}

\subsubsection{Data Structures}

\noindent \textsf{Dispute Intent}. A \textit{dispute intent} happens when a user claims a developer is dishonest and no dispute against that developer is open. The developer or any other user then has 7 days to answer the dispute. If someone answers the dispute, be it the developer or any other user, the dispute is opened and the minimum fees needed to open it are captivated. If no user answers the dispute, the \textit{dispute intent} closes and the developer status changes to \textit{critical}. \\

\noindent \textsf{Dispute}. A \textit{dispute} is a conflict between two parties, where one party - the \textit{contestants} - claim that a developer is dishonest, i.e. the developer uploads apps with malware, too many ads, or non-working apps, and the other party - the \textit{pleaders} - claim the developer is honest. The pleaders include the developer being accused of dishonesty by the contestants. Both parties place tokens in the dispute and the party holding the most amount of tokens by the end of the dispute wins. Therefore, the \textit{dispute} includes the developer it regards to, the participants in both parties and their respective stake in the dispute. \\

\noindent \textsf{Ledger}. The \textit{ledger} is the record of disputes and changes in status of developers. Regarding the disputes, it records their results, including the participants of both parties and the amount each participant put at stake. Concerning changes in status, it records the developer, his previous and new statuses, and reason for change (promotion or dispute).

\begin{table}[H]
\footnotesize
\centering
\begin{tabular}{|p{1.0\textwidth}|}
\hline
\multicolumn{1}{|c|}{Data Structures} \\
\hline \vspace{0.05cm}
\textbf{DisputeIntent} \\
dispute intent $K^{0}_{x} := \langle D_i, C_i, T_{min}\rangle$
\begin{itemize}
	\item Developer $D_i$, the developer being accused of being dishonest
	\item Contestant $C_i$, user claiming developer $D_i$ is dishonest
	\item Minimum fee $T_{min}$, the minimum fee needed to open the dispute that may result from this dispute intent
\end{itemize} \\
\textbf{Dispute} \\
dispute $K_x := \langle D_i, C, P, T_C, T_P\rangle$
\begin{itemize}
	\item Developer $D_i$, the developer being accused of being dishonest
	\item Contestants $C$, the set of users claiming that the developer $D_i$ is dishonest
	\item Pleaders $P$, the set of users claiming that the developer $D_i$ is honest
	\item Contestants' stakes $T_C$, the list of amount of tokens put at stake by the contestants
	\item Pleaders' stakes $T_P$, the list of amount of tokens put at stake by the pleaders
\end{itemize} \\
\textbf{Ledger} \\
ledger $L : (E_1..E_n)$
\begin{itemize}
	\item Entry $E_i$, a record of an event related with Developers Approval use case
	\begin{itemize}
		\item It can be a record of a dispute or a developer's status change
		\begin{itemize}
			\item If it is the former, $E_i$ is of the form $E := \langle R, D_i, C, P, T_C, T_P\rangle$, where $R$ is the result of the dispute
			\item If it is the latter, $E_i$ is of the form $E := \langle D_i, S_b, S_a\rangle$, where $S_b$ is the developer's status before the change and $S_a$ is the status after the change
		\end{itemize}
	\end{itemize}
\end{itemize} \\
\hline
\end{tabular}
\caption{Data Structures for Developers Approval Use Case}
\label{table: data_structures_da}
\end{table}

\subsubsection{Algorithm construction}

\noindent \textbf{Create dispute intent}. When a user $C_i$ claims a developer $D_j$ is dishonest, an intent of dispute is created, which may or not result in a dispute being opened, depending on whether someone answers the dispute within 7 days or not. The user answering the dispute may not be the developer. \\

\textsf{DA.CreateDisputeIntent}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item User $C_i$
		\item Developer $D_j$
		\item Minimum fee $T_{min}$
	\end{itemize}
	\item OUTPUTS: None
\end{itemize}

\noindent \textbf{Open dispute}. When a dispute intent is answered, a disputed is opened. Within the following 30 days, any user may join the contestants side, which is composed by users claiming the developer $D_j$ is dishonest, or the pleaders side, which contains users stating that the developer $D_j$ is honest. When the dispute is over, the winning side has its stakes refunded, while also receiving 10\% of each pledge from the losing side, with each winning member getting a winning stake proportional to their stake in the overall winning side pledge. Each member from the losing side gets a refund from the respective pledge subtracted by 10\%.\\

\textsf{DA.OpenDispute}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item Contestant $C_i$
		\item Developer $D_j$
		\item Pleader $P_z$
		\item Minimum fee $T_{min}$
	\end{itemize}
	\item OUTPUTS: None
\end{itemize}

\noindent \textbf{Set record}. When an event related with a developer's status change, being it a dispute result or a status changes, it gets recorded in the ledger. \\

\textsf{DA.SetRecord}
\begin{itemize}
	\item INPUTS:
	\begin{itemize}
		\item Record $R$
		\item Record type $R_t$
	\end{itemize}
	\item OUTPUTS: None
\end{itemize}

\begin{table}[H]
\scriptsize
\centering
\begin{tabular}{|p{.4\textwidth}p{.6\textwidth}|}
\hline
\multicolumn{2}{|c|}{Developers Approval Use Case} \\
\hline \vspace{0.1cm}
\textsf{DA.CreateDisputeIntent}
\vspace{-0.3cm}
\begin{itemize}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item User $C_i$
		\item Developer $D_j$
		\item Minimum fee $T_{min}$
	\end{itemize}
	\item OUTPUTS: \textit{None}
\end{itemize}
\begin{enumerate}
	\item Send minimum fee $T_{min}$ from contestant's wallet $W_C$ to dispute intent's wallet $W_{K^0}$
	\item Set $days := 0$
	\item Set $Answer := None$
	\item While $days < 7$:
	\begin{enumerate}
		\item If $answer$ arrives:
		\begin{enumerate}
			\item Set $Answer := answer$
			\item Break
		\end{enumerate}
	\end{enumerate}
	\item If $Answer$ != \textit{None}:
	\begin{enumerate}
		\item Set $K$ := \textsf{DA.OpenDispute}($D_i$, $C_i$, $Answer$.Pleader)
		\item Send minimum fee $T_{min}$ correspondent to $C_i$ from dispute intent's wallet $W_{K^0}$ to dispute's wallet $W_K$
		\item Send minimum fee $T_{min}$ correspondent to $Answer$.Pleader from dispute intent's wallet $W_P$ to dispute's wallet $W_K$
	\end{enumerate}
	\item Else:
	\begin{enumerate}
		\item Send minimum fee $T_{min}$ correspondent to $C_i$ from $W_{K^0}$ to $W_C$ (refund)
		\item Set $R$ := ($D_i$.Status, \textit{"Critical"})
		\item Compute \textsf{DA.SetRecord}($R$, \textit{"StatusChange"})
	\end{enumerate}
\end{enumerate} & \vspace{0.1cm}
\textsf{DA.OpenDispute}
\vspace{-0.3cm}
\begin{itemize}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item Contestant $C_i$
		\item Developer $D_j$
		\item Pleader $P_z$
		\item Minimum fee $T_{min}$
	\end{itemize}
	\item OUTPUTS: None
\end{itemize}
\begin{enumerate}
	\item Set $C := List(C_i)$
	\item Set $P := List(P_z)$
	\item Set $T_C := List(T_{min})$
	\item Set $T_P := List(T_{min})$
	\item Set $days := 0$
	\item While $days < 30$:
	\begin{enumerate}
		\item If contestant $C_k$ arrives:
		\begin{enumerate}
			\item Compute $C$.\textsf{append}($C_k$)
			\item Compute $T_C$.\textsf{append}($C_k$.Pledge)
			\item Send $C_k$.Pledge from contestant's wallet $W_{C_K}$ to dispute's wallet $W_K$
		\end{enumerate}
		\item If pleader $P_k$ arrives:
		\begin{enumerate}
			\item Compute $P$.\textsf{append}($P_k$)
			\item Compute $T_P$.\textsf{append}($P_k$.Pledge)
			\item Send $P_k$.Pledge from pleader's wallet $W_{P_K}$ to $W_K$
		\end{enumerate}
	\end{enumerate}
	\item Compute \textsf{DistributePledges}($T_P$, $T_C$)
%	\item If \textsf{Sum}($T_P$) $\geq$ \textsf{Sum}($T_C$):
%	\begin{enumerate}
%		\item Compute $(E^{P}_{1}..E^{P}_{n})$ := \textsf{PledgesWin}($T_C$) (winning fees proportional to stake in dispute)
%		\item Compute $(E^{C}_{1}..E^{C}_{n})$ := \textsf{PledgesLoser}($T_C$) (stakes put in dispute subtracted by the percentage of losing)
%		\item For each pleader $p$ in $P$:
%		\begin{enumerate}
%			\item Send pledge $T_p$ in $T_P$ from $W_K$ to pleader's wallet $W_p$ (refund from winning dispute)
%			\item Send winning pledge $E^{P}_{p}$ from $W_K$ to $W_p$
%		\end{enumerate}
%		\item For each contestant $c$ in $C$:
%		\begin{enumerate}
%			\item Send pledge $E^{C}_{c}$ from $W_K$ to contestant's wallet $W_c$
%		\end{enumerate}
%	\end{enumerate}
	\item If \textsf{Sum}($T_C$) $<$ \textsf{Sum}($T_P$):
	\begin{enumerate}
		\item Set $R_S$ := ($D_i$.Status, \textit{"Critical"})
		\item Compute \textsf{DA.SetRecord}($R_S$, \textit{"StatusChange"})
		\item Set $R_D$ :=  (\textit{"ContestantsWin"}, $C$, $P$, $T_C$, $T_P$)
		\item Compute \textsf{DA.SetRecord}($R_D$, \textit{"Dispute"})
	\end{enumerate}
	\item Else:
	\begin{enumerate}
		\item Set $R_D$ :=  (\textit{"PleadersWin"}, $C$, $P$, $T_C$, $T_P$)
		\item Compute \textsf{DA.SetRecord}($R_D$, \textit{"Dispute"})
	\end{enumerate}
\end{enumerate} \\
\textsf{DA.SetRecord}
\vspace{-0.3cm}
\begin{itemize}
	\item INPUTS:
	\vspace{-0.4cm}
	\begin{itemize}
		\item Record $R$
		\item Record type $R_t$
	\end{itemize}
	\item OUTPUTS: None
\end{itemize}
\begin{enumerate}
	\item Compute \textsf{WriteLedger}($R$, $R_t$)
\end{enumerate}
& \\
\hline
\end{tabular}
\caption{Developers Approval Use Case}
\label{table: da_protocol}
\end{table}











